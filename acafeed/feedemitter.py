"""
Emit a combined RSS feed using entries fetched by FeedSource without modifying them.

Follow the notebook demo's spirit but do not filter, deduplicate, or reorder entries.
Also provide a helper to auto push the generated XML to a remote branch.
"""
from __future__ import annotations

from datetime import datetime, timezone
from typing import Any, Dict, Iterable, List, Optional
import os
import subprocess

from feedgen.feed import FeedGenerator
from .feedmanager import FeedSource


class FeedEmitter:
    """
    Use a FeedSource to fetch entries from configured feeds and emit an RSS file.

    - No modification on entries: no filtering, no dedup, no reordering.
    - The output order is exactly the order returned by each parsed feed,
      iterated in the order of FeedSource's internal name list.
    - Provide a convenience method to commit and push the generated file.
    """

    def __init__(
        self,
        feed_source: FeedSource,
        *,
        title: str = "Acafeed Generated Feed",
        home_page: str = "https://github.com/JedimasterLu/acafeed",
        description: str = "This feed is generated by Acafeed.",
        language: str = "en",
    ) -> None:
        self.feed_source = feed_source
        fg = FeedGenerator()
        fg.id(home_page)
        fg.title(title)
        fg.link(href=home_page, rel="alternate")
        fg.description(description)
        fg.language(language)
        self._fg = fg

    def aggregate_entries(self, names: Optional[Iterable[str]] = None) -> List[Dict[str, Any]]:
        """
        Fetch entries from FeedSource for the given names (or all stored names).
        Returns a simple list of entry dicts exactly as returned by feedparser.
        """
        if names is None:
            # Use FeedSource's exposed names property to keep user-defined order
            names = list(getattr(self.feed_source, "names", []))
        entries: List[Dict[str, Any]] = []
        for name in names:
            parsed = self.feed_source.fetch(name)
            if parsed is None:
                continue
            for e in getattr(parsed, "entries", []) or []:
                entries.append(e)
        return entries

    def write_rss(self, entries: List[Dict[str, Any]], output_path: str = "feed.xml") -> str:
        """
        Write RSS using feedgen from the exact entries without modifications.
        """
        fg = self._fg
        for e in entries:
            fe = fg.add_entry()
            # id: prefer link, then id, then title
            key = e.get("link") or e.get("id") or (e.get("title") or "")
            if key:
                fe.id(key)
            title = e.get("title") or (e.get("summary") or "Untitled")
            fe.title(title)
            link = e.get("link")
            if link:
                fe.link(href=link)
            # keep summary/description as-is
            if e.get("summary") or e.get("description"):
                fe.description(e.get("summary") or e.get("description"))
            # Author
            authors = e.get("authors")
            author_list = [a['name'] for a in authors] if authors else []
            if author_list:
                fe.author({"name": ", ".join(author_list)})
            # published date (if present)
            dt_struct = e.get("published_parsed") or e.get("updated_parsed")
            if dt_struct:
                try:
                    fe.published(datetime(*dt_struct[:6], tzinfo=timezone.utc))
                except Exception:
                    pass

        fg.rss_file(output_path, pretty=True)
        return output_path

    def commit_and_push(
        self,
        file_path: str = "feed.xml",
        *,
        remote: str = "origin",
        branch: Optional[str] = None,
        message: str = "chore: update feed.xml",
    ) -> None:
        """
        Commit and push the generated file to the given remote/branch.
        Skips commit if no staged changes for the file.
        """
        # Determine repo root
        repo_root = (
            subprocess.run(
                ["git", "rev-parse", "--show-toplevel"],
                text=True,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                check=True,
            ).stdout.strip()
        )
        target = file_path if os.path.isabs(file_path) else os.path.join(repo_root, file_path)

        subprocess.run(["git", "add", target], check=True)
        # Check if anything staged for this file
        diff_rc = subprocess.run(["git", "diff", "--cached", "--quiet", "--", target]).returncode
        if diff_rc == 0:
            print(f"No changes to commit for {os.path.relpath(target, repo_root)}")
            return

        subprocess.run(["git", "commit", "-m", message], check=True)
        if branch is None:
            branch = (
                subprocess.run(
                    ["git", "rev-parse", "--abbrev-ref", "HEAD"], text=True, stdout=subprocess.PIPE, check=True
                ).stdout.strip()
            )
        subprocess.run(["git", "push", remote, branch], check=True)
        print(f"Pushed {os.path.relpath(target, repo_root)} to {remote}/{branch}")

    def generate_and_push(
        self,
        output_path: str = "feed.xml",
        *,
        remote: str = "origin",
        branch: Optional[str] = None,
        message: str = "chore: update feed.xml",
        names: Optional[Iterable[str]] = None,
    ) -> str:
        """
        Aggregate entries via FeedSource, write RSS to output_path, and push.
        Returns the output path.
        """
        entries = self.aggregate_entries(names=names)
        out = self.write_rss(entries, output_path)
        self.commit_and_push(out, remote=remote, branch=branch, message=message)
        return out

